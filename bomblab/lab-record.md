# Bomblab实验记录

***

## 实验环境

> apt policy {name} 和 lsb_release 获取到版本信息

- ubuntu-22.04.3-desktop-amd64.isoVMvituralbox 上运行的Ubuntu系统，版本Ubuntu 22.04.3 LTS Desktop版，安装包名ubuntu-22.04.3-desktop-amd64.iso

- gcc版本 4:11.2.0-1ubuntu1
* gdb版本12.1-0ubuntu1~22.04.1

***

## GDB常用命令

```
r                    #运行程序
b {函数名/行数}       #打断点
stepi                #单步汇编指令执行
finish               #执行完当前函数并在跳出后暂停执行，提供返回值
quit                 #退出gdb
d {num}               #删除指定编号断点
disas {fun/add}       #反汇编某函数、地址
layout asm            #在终端实时显示汇编指令执行
ctrl+x+a  ctrl+l      #退出layout 刷新显示
p *(int*)($rax+0x8)    #以int打印根据%rax寄存器储存地址偏移0x8处储存的值
p/x $rax               #以16进制打印寄存器储存的值
x/d x/c x/s + {addr/$寄存器}   #以十进制整数、字符、字符串打印地址处的值
```

***

**另附发现的git分支切换问题，当分支修改并未整合到master支中时不能直接切换到主支，解决方法应先储藏分支，切换至主支行动完成后再弹回分支**

```
git stash
git switch master
''''
git switch dev
git stash pop
```

***

## 正式实验：phase_1

首先反汇编bomb文件得到bomb.s备用

> objdump -d bomb > bomb.s

先看汇编代码中的main函数，可以看到

```asmatmel
0000000000400da0 <main>:
""""
  400e2d:    e8 de fc ff ff           call   400b10 <puts@plt>
  400e32:    e8 67 06 00 00           call   40149e <read_line>
  400e37:    48 89 c7                 mov    %rax,%rdi
  400e3a:    e8 a1 00 00 00           call   400ee0 <phase_1>
  400e3f:    e8 80 07 00 00           call   4015c4 <phase_defused>
  400e44:    bf a8 23 40 00           mov    $0x4023a8,%edi
  400e49:    e8 c2 fc ff ff           call   400b10 <puts@plt>
  400e4e:    e8 4b 06 00 00           call   40149e <read_line>
  400e53:    48 89 c7                 mov    %rax,%rdi
  400e56:    e8 a1 00 00 00           call   400efc <phase_2>
  400e5b:    e8 64 07 00 00           call   4015c4 <phase_defused>
  400e60:    bf ed 22 40 00           mov    $0x4022ed,%edi
```

可以看到在call phase_1函数前输入是通过read_line函数获取的，返回值%rax给到%rdi，初步判断输入是通过寄存器%rdi传递的，如果符合要求就跳转到phase_defused后进入下一关。

先用gdb调试bomb程序，在phase_1处打断点，然后反汇编，得到结果

```
(gdb) b phase_1
(gdb) r
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
sdsd
Breakpoint 1, 0x0000000000400ee0 in phase_1 ()
(gdb) disas
Dump of assembler code for function phase_1:
=> 0x0000000000400ee0 <+0>:     sub    $0x8,%rsp
   0x0000000000400ee4 <+4>:     mov    $0x402400,%esi
   0x0000000000400ee9 <+9>:     call   0x401338 <strings_not_equal>
   0x0000000000400eee <+14>:    test   %eax,%eax
   0x0000000000400ef0 <+16>:    je     0x400ef7 <phase_1+23>
   0x0000000000400ef2 <+18>:    call   0x40143a <explode_bomb>
   0x0000000000400ef7 <+23>:    add    $0x8,%rsp
   0x0000000000400efb <+27>:    ret    
End of assembler dump.
```

可以看到函数1首先将一个立即数放到%esi里，之后call函数<strings_not_equal>，从名称可以推断是判断输入字符与规定字符串是否相等，相等会返回0,不相等返回1（可以通过执行到函数内后用finish命令得到返回值），则推测立即数$0x402400所在存放的是要求字符串。输入指令

```
(gdb) x/s $esi
0x402400:       "Border relations with Canada have never been better."
```

则可以得到第一关的答案。

可以将答案统一写到一个文件中ans.txt,避免多次输入答案，用如下命令运行：

> ./bomb < ans.txt

***

## phase_2

同理，先在函数2打断点，然后反汇编，先看到前几行

```asmatmel
=> 0x0000000000400efc <+0>:     push   %rbp
   0x0000000000400efd <+1>:     push   %rbx
   0x0000000000400efe <+2>:     sub    $0x28,%rsp
   0x0000000000400f02 <+6>:     mov    %rsp,%rsi
   0x0000000000400f05 <+9>:     call   0x40145c <read_six_numbers>
   0x0000000000400f0a <+14>:    cmpl   $0x1,(%rsp)
```

可以看到第二关会读取6个数字，应该是会在栈上储存的，可以看到分配了0x28字节的栈空间，当执行到<+14>时比较0x1和栈底储存的值，推断输入的数应该为int类型，接下来的汇编代码

```asmatmel
  0x0000000000400f0e <+18>:    je     0x400f30 <phase_2+52>
   0x0000000000400f10 <+20>:    call   0x40143a <explode_bomb>
   0x0000000000400f15 <+25>:    jmp    0x400f30 <phase_2+52>
   0x0000000000400f17 <+27>:    mov    -0x4(%rbx),%eax
   0x0000000000400f1a <+30>:    add    %eax,%eax
   0x0000000000400f1c <+32>:    cmp    %eax,(%rbx)
   0x0000000000400f1e <+34>:    je     0x400f25 <phase_2+41>
   0x0000000000400f20 <+36>:    call   0x40143a <explode_bomb>
   0x0000000000400f25 <+41>:    add    $0x4,%rbx
   0x0000000000400f29 <+45>:    cmp    %rbp,%rbx
   0x0000000000400f2c <+48>:    jne    0x400f17 <phase_2+27>
   0x0000000000400f2e <+50>:    jmp    0x400f3c <phase_2+64>
   0x0000000000400f30 <+52>:    lea    0x4(%rsp),%rbx
   0x0000000000400f35 <+57>:    lea    0x18(%rsp),%rbp
   0x0000000000400f3a <+62>:    jmp    0x400f17 <phase_2+27>
   0x0000000000400f3c <+64>:    add    $0x28,%rsp
   0x0000000000400f40 <+68>:    pop    %rbx
   0x0000000000400f41 <+69>:    pop    %rbp
   0x0000000000400f42 <+70>:    ret    
```

当（%rsp）与1相等时跳转至<+52>，否则爆炸，则输入的第一个数是1

<+52>处将栈指针偏移0x4处的地址取到%rbx,因为推断输入为int，则此处将第二个输入的地址给%rbx，下一行已经超过读取的数字范围，即输入的第6个数地址的上面，先忽略。接下来跳到+27

%eax里的值为%rbx地址下移0x4后储存的值，即为第一个输入的数，1。之后累加输入1与输入2比较，因此输入2为2.相等后调至+41行，%rbx地址向上移0x4，即指向输入3，下一行比较令%rbx地址不超过最大6个数的范围，之后循环，每次将当前%rbx里的值翻倍，与下一个输入比较。所以输入数字序列为1 2 4 8 16 32

| 栈示意图(栈顶) | 每格高4字节             |
|:--------:|:------------------:|
| ??       | %rbp               |
| a6       |                    |
| a5       |                    |
| a3       |                    |
| a3       |                    |
| a2       | 首次%rbx指向（%rsp+0x4） |
| a1       | %rsp               |

***

## phase_3

同理先看汇编代码

```asmatmel
=> 0x0000000000400f43 <+0>:     sub    $0x18,%rsp
   0x0000000000400f47 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000400f4c <+9>:     lea    0x8(%rsp),%rdx
   0x0000000000400f51 <+14>:    mov    $0x4025cf,%esi
   0x0000000000400f56 <+19>:    mov    $0x0,%eax
   0x0000000000400f5b <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000400f60 <+29>:    cmp    $0x1,%eax
   0x0000000000400f63 <+32>:    jg     0x400f6a <phase_3+39>
   0x0000000000400f65 <+34>:    call   0x40143a <explode_bomb>  
   0x0000000000400f6a <+39>:    cmpl   $0x7,0x8(%rsp)
   0x0000000000400f6f <+44>:    ja     0x400fad <phase_3+106>
   0x0000000000400f71 <+46>:    mov    0x8(%rsp),%eax
   0x0000000000400f75 <+50>:    jmp    *0x402470(,%rax,8)
   0x0000000000400f7c <+57>:    mov    $0xcf,%eax
   0x0000000000400f81 <+62>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f83 <+64>:    mov    $0x2c3,%eax
   0x0000000000400f88 <+69>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f8a <+71>:    mov    $0x100,%eax
   0x0000000000400f8f <+76>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f91 <+78>:    mov    $0x185,%eax
   0x0000000000400f96 <+83>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f98 <+85>:    mov    $0xce,%eax
   0x0000000000400f9d <+90>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400f9f <+92>:    mov    $0x2aa,%eax
   0x0000000000400fa4 <+97>:    jmp    0x400fbe <phase_3+123>
   0x0000000000400fa6 <+99>:    mov    $0x147,%eax
   0x0000000000400fab <+104>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fad <+106>:   call   0x40143a <explode_bomb>
   0x0000000000400fb2 <+111>:   mov    $0x0,%eax
   0x0000000000400fb7 <+116>:   jmp    0x400fbe <phase_3+123>
   0x0000000000400fb9 <+118>:   mov    $0x137,%eax
   0x0000000000400fbe <+123>:   cmp    0xc(%rsp),%eax
   0x0000000000400fc2 <+127>:   je     0x400fc9 <phase_3+134>
   0x0000000000400fc4 <+129>:   call   0x40143a <explode_bomb>
   0x0000000000400fc9 <+134>:   add    $0x18,%rsp
   0x0000000000400fcd <+138>:   ret    
```

<+24>处调用scanf函数，返回成功读取的项数，则据<+32>可知读取项数应该大于1。

通过`x/s 0x4025cf`显示为`0x4025cf:       "%d %d"`可以判断scanf函数的读取的两数都是int类型

接下来到<+39>行，通过打印0x8(%rsp)处的值可以推测出此处为输入的第一个参数，输入1与7比较，无符号大于会爆炸，则输入1是[0,7]之间的数，随便猜一个数2.

<+50>行jmp\*表示间接跳转，跳转位置为（0x402470+8*%rax）= (0x402480),即从内存位置402480开始读出跳转地址，我的机器为小端储存，则通过`x/3x 0x402480`可以看出跳转地址位置为0x400f83。不过最简单的方法是在gdb上直接运行，会跳转到<+64>

通过实验0xc(%rsp)是第二个输入的地址，则输入应该与0x2c3相等，即707。所以答案的一种为2 707。

整个phase_3应该是通过第一个输入决定相对于0x402470的偏移位置从而跳转到不同的执行行，决定第二个输入。

***

## phase_4

类似以上任务，打断点，反汇编。

```asmatmel
=> 0x000000000040100c <+0>:     sub    $0x18,%rsp
   0x0000000000401010 <+4>:     lea    0xc(%rsp),%rcx
   0x0000000000401015 <+9>:     lea    0x8(%rsp),%rdx
   0x000000000040101a <+14>:    mov    $0x4025cf,%esi
   0x000000000040101f <+19>:    mov    $0x0,%eax
   0x0000000000401024 <+24>:    call   0x400bf0 <__isoc99_sscanf@plt>
   0x0000000000401029 <+29>:    cmp    $0x2,%eax
   0x000000000040102c <+32>:    jne    0x401035 <phase_4+41>
   0x000000000040102e <+34>:    cmpl   $0xe,0x8(%rsp)
   0x0000000000401033 <+39>:    jbe    0x40103a <phase_4+46>
   0x0000000000401035 <+41>:    call   0x40143a <explode_bomb>
```

开始部分与phase_3类似，可以看出输入应该为两个int类整数，并且两输入存储在0x8(%rsp)和0xc(%rsp)。看<+34>行，比较输入1与14的大小，需要无符号<=才不会爆炸，则第一个参数的范围[0,14]。继续看汇编代码。

```asmatmel
   0x0000000000401035 <+41>:    call   0x40143a <explode_bomb>
   0x000000000040103a <+46>:    mov    $0xe,%edx
   0x000000000040103f <+51>:    mov    $0x0,%esi
   0x0000000000401044 <+56>:    mov    0x8(%rsp),%edi
   0x0000000000401048 <+60>:    call   0x400fce <func4>
   0x000000000040104d <+65>:    test   %eax,%eax
   0x000000000040104f <+67>:    jne    0x401058 <phase_4+76>
   0x0000000000401051 <+69>:    cmpl   $0x0,0xc(%rsp)
   0x0000000000401056 <+74>:    je     0x40105d <phase_4+81>
   0x0000000000401058 <+76>:    call   0x40143a <explode_bomb>
   0x000000000040105d <+81>:    add    $0x18,%rsp
   0x0000000000401061 <+85>:    ret    
```

+46行开始在%edx内存0xe，在%esi储存0x0,通过%edi传递输入1。之后调用函数func4，先等会分析这个函数，看+65行的代码在phase_1中看到过，主要是为了判断%eax中的值是正负还是0，若是返回不为0会发生爆炸。若输入1合法，+69判断的是输入2与0的关系，不相等会调用爆炸，则输入2是0.现在看func4.

```asmatmel
   0x0000000000400fce <+0>:     sub    $0x8,%rsp
   0x0000000000400fd2 <+4>:     mov    %edx,%eax
   0x0000000000400fd4 <+6>:     sub    %esi,%eax
   0x0000000000400fd6 <+8>:     mov    %eax,%ecx
   0x0000000000400fd8 <+10>:    shr    $0x1f,%ecx
   0x0000000000400fdb <+13>:    add    %ecx,%eax
   0x0000000000400fdd <+15>:    sar    %eax
   0x0000000000400fdf <+17>:    lea    (%rax,%rsi,1),%ecx
   0x0000000000400fe2 <+20>:    cmp    %edi,%ecx
   0x0000000000400fe4 <+22>:    jle    0x400ff2 <func4+36>
   0x0000000000400fe6 <+24>:    lea    -0x1(%rcx),%edx
   0x0000000000400fe9 <+27>:    call   0x400fce <func4>
   0x0000000000400fee <+32>:    add    %eax,%eax
   0x0000000000400ff0 <+34>:    jmp    0x401007 <func4+57>
   0x0000000000400ff2 <+36>:    mov    $0x0,%eax
   0x0000000000400ff7 <+41>:    cmp    %edi,%ecx
   0x0000000000400ff9 <+43>:    jge    0x401007 <func4+57>
   0x0000000000400ffb <+45>:    lea    0x1(%rcx),%esi
   0x0000000000400ffe <+48>:    call   0x400fce <func4>
   0x0000000000401003 <+53>:    lea    0x1(%rax,%rax,1),%eax
   0x0000000000401007 <+57>:    add    $0x8,%rsp
   0x000000000040100b <+61>:    ret    
```

大体看一下func4函数是进行了递归调用，初始时%edx为14，%esi为0，%edi为输入1.

操作为将`%edx-%esi`的值储存在`%eax`上，并将`%eax`的值赋给`%ecx`。对%ecx进行逻辑右移shr31位，最高位空缺用0填充。相当于只剩余原符号位，原数是正或0时结果为0，原数是负结果为1.之后将%ecx累加到%eax上(即若%edx-%esi的值为正或0时%eax不变，为负时结果加1)。之后对%eax进行逻辑右移sar，只有一个操作数，应该是位移1位的缩写，等效于原数最后一位清零后再除以2(可以证明无论是正是负)。

+17行用lea指令进行简单的运算，用`%rax`里的值`+%rsi`的值给到`%ecx`(刚才进行了逻辑右移后的值，为0或1，没什么用了)，比较其与输入1的大小，有符号<=即跳到+36行，将%eax清零，再次比较%输入1与%ecx的大小，有符号>=可以结束函数，此时%eax里的值为0，回忆func4返回后应该保证%rax的值为0，则函数最终应该跳转到此处后结束才能符合要求，通过这两次判断可以得到一个符合的值7.则（7 0）是一个答案。

分析func4函数，得到以下伪代码：

```
int a = 14, b = 0, c = input, t,d;  //三个变量分别在%edx,%esi,%edi,以及临时值
//t在%rax，d在%ecx
//func前半部分进行操作如下
t = a-b;
t + = (t >= 0) ?  0 ：1；
t - = (t/2 == 0) ? 0 : 1:
t = t / 2;
d = t + b;
if d >= c
    a = d - 1;  func4;
else 
    t = 0;
    if d <= c
        b = d + 1;  func4;
     else 
        t = 2t + 1;
```

类似于进行了二分查找，输入1等于7,3,1,0都可以通过 d <= c 的判断后离开。输入大于7的都不符合要求。

***

## phase_5

```asmatmel
=> 0x0000000000401062 <+0>:     push   %rbx
   0x0000000000401063 <+1>:     sub    $0x20,%rsp
   0x0000000000401067 <+5>:     mov    %rdi,%rbx
   0x000000000040106a <+8>:     mov    %fs:0x28,%rax
   0x0000000000401073 <+17>:    mov    %rax,0x18(%rsp)
   0x0000000000401078 <+22>:    xor    %eax,%eax
   0x000000000040107a <+24>:    call   0x40131b <string_length>
   0x000000000040107f <+29>:    cmp    $0x6,%eax
   0x0000000000401082 <+32>:    je     0x4010d2 <phase_5+112>
   0x0000000000401084 <+34>:    call   0x40143a <explode_bomb>
```

由前端可以看出输入应为字符串，准确来说是字符数，长度是6。+8行开始是栈溢出保护，在下一个lab时可以了解到部分信息。

```asmatmel
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>

   0x00000000004010d2 <+112>:   mov    $0x0,%eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   call   0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   ret    
```

相等时跳到+112行，令%eax为0，跳到+41行，输入的字符应该储存在了栈里。

```asmatmel
   0x0000000000401089 <+39>:    jmp    0x4010d2 <phase_5+112>
   0x000000000040108b <+41>:    movzbl (%rbx,%rax,1),%ecx
   0x000000000040108f <+45>:    mov    %cl,(%rsp)
   0x0000000000401092 <+48>:    mov    (%rsp),%rdx
   0x0000000000401096 <+52>:    and    $0xf,%edx
   0x0000000000401099 <+55>:    movzbl 0x4024b0(%rdx),%edx
   0x00000000004010a0 <+62>:    mov    %dl,0x10(%rsp,%rax,1)
   0x00000000004010a4 <+66>:    add    $0x1,%rax
   0x00000000004010a8 <+70>:    cmp    $0x6,%rax
   0x00000000004010ac <+74>:    jne    0x40108b <phase_5+41>
   ***
   0x00000000004010ae <+76>:    movb   $0x0,0x16(%rsp)
   0x00000000004010b3 <+81>:    mov    $0x40245e,%esi
   0x00000000004010b8 <+86>:    lea    0x10(%rsp),%rdi
   0x00000000004010bd <+91>:    call   0x401338 <strings_not_equal>
   0x00000000004010c2 <+96>:    test   %eax,%eax
   0x00000000004010c4 <+98>:    je     0x4010d9 <phase_5+119>
   0x00000000004010c6 <+100>:   call   0x40143a <explode_bomb>
   0x00000000004010cb <+105>:   nopl   0x0(%rax,%rax,1)
   0x00000000004010d0 <+110>:   jmp    0x4010d9 <phase_5+119>
   0x00000000004010d2 <+112>:   mov    $0x0,%eax
   0x00000000004010d7 <+117>:   jmp    0x40108b <phase_5+41>
   0x00000000004010d9 <+119>:   mov    0x18(%rsp),%rax
   0x00000000004010de <+124>:   xor    %fs:0x28,%rax
   0x00000000004010e7 <+133>:   je     0x4010ee <phase_5+140>
   0x00000000004010e9 <+135>:   call   0x400b30 <__stack_chk_fail@plt>
   0x00000000004010ee <+140>:   add    $0x20,%rsp
   0x00000000004010f2 <+144>:   pop    %rbx
   0x00000000004010f3 <+145>:   ret    
```

+41行将%rbx出偏移1个%rax的值储存到%ecx里，通过`p (char) $ecx`打印发现此处存放的是输入字符1。然后将%rcx最后8位值附给栈指针指向位置，并赋给%rdx。

下一行对%rdx进行掩码操作，只保留最后4位，即输入字符的最后四位是有效字符。然后将%rdx当做偏移值得到内存地址`0x4024b0`偏移后的值。打印此处的字符串得到

`maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?`

则目的字符应该是通过输入字符取后四位作偏移值取maduiersnfotvbylSo得到的。储存到%edx

之后将%rdx后8位(实际是从0x4024b0出偏移后的字符编码)给到0x10(%rsp,%rax,1)这个内存位置，是在栈上。%rax累加1，作这个循环，取到每个输入的后4位储存到栈上。

直到%rax=6，令0x16(%rsp)为0。通过之前可以看出，输入储存位置从栈指针位置开始向上储存，偏移后的字符从0x10(%rsp)开始储存。则0x16(%rsp)正好在字符储存的位置上面，构成一个字符串。通过打印地址`0x40245e`处得到`"flyers"`，这个应该是目标字符串，通过strings_not_equal判断字符串是否相等。所以输入字符的# ASCII编码后四位应该为偏移值9 15 14 5 6 7，查询编码表可以得到一个答案。`9?>567`

***

## phase_6

```asmatmel
=> 0x00000000004010f4 <+0>:     push   %r14
   0x00000000004010f6 <+2>:     push   %r13
   0x00000000004010f8 <+4>:     push   %r12
   0x00000000004010fa <+6>:     push   %rbp
   0x00000000004010fb <+7>:     push   %rbx
   0x00000000004010fc <+8>:     sub    $0x50,%rsp
   0x0000000000401100 <+12>:    mov    %rsp,%r13
   0x0000000000401103 <+15>:    mov    %rsp,%rsi
   0x0000000000401106 <+18>:    call   0x40145c <read_six_numbers>
   0x000000000040110b <+23>:    mov    %rsp,%r14
   0x000000000040110e <+26>:    mov    $0x0,%r12d
   0x0000000000401114 <+32>:    mov    %r13,%rbp
   0x0000000000401117 <+35>:    mov    0x0(%r13),%eax
   0x000000000040111b <+39>:    sub    $0x1,%eax
   0x000000000040111e <+42>:    cmp    $0x5,%eax
   0x0000000000401121 <+45>:    jbe    0x401128 <phase_6+52>
   0x0000000000401123 <+47>:    call   0x40143a <explode_bomb>
```

可以看出phsae_6的输入是6个数字，猜测还是int类型。将栈指针储存在%r13和%rsi里，分别为被调用者保存寄存器和调用者保存寄存器。所以调用完读取函数后%r13一定保存为%rsp的值。

之后进行一定的寄存器数值改变`%r14 = %rsp, %r12d = 0, %rbp = %r13 = %rsp`然后将%r13/%rsp处的值给到%eax,通过试验发现此处的值为输入1，则输入储存在栈底处。之后将%eax-1与5比较，大于就会爆炸,jbe是无符号小于等于，不能为负，所以输入范围[1,6]

```asmatmel
   0x0000000000401128 <+52>:    add    $0x1,%r12d
   0x000000000040112c <+56>:    cmp    $0x6,%r12d
   0x0000000000401130 <+60>:    je     0x401153 <phase_6+95>
   0x0000000000401132 <+62>:    mov    %r12d,%ebx
   0x0000000000401135 <+65>:    movslq %ebx,%rax
   0x0000000000401138 <+68>:    mov    (%rsp,%rax,4),%eax
   0x000000000040113b <+71>:    cmp    %eax,0x0(%rbp)
   0x000000000040113e <+74>:    jne    0x401145 <phase_6+81>
   0x0000000000401140 <+76>:    call   0x40143a <explode_bomb>
   0x0000000000401145 <+81>:    add    $0x1,%ebx
   0x0000000000401148 <+84>:    cmp    $0x5,%ebx
   0x000000000040114b <+87>:    jle    0x401135 <phase_6+65>
   0x000000000040114d <+89>:    add    $0x4,%r13
   0x0000000000401151 <+93>:    jmp    0x401114 <phase_6+32>
   0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi
```

`%r12d += 1`当r12d小于6时，另`%ebx = %r12d =1, %rax = %ebx = %r12d = 1`将(%rsp, %rax,4)处的值给到eax，通过之前分析此处值为输入2，之后与0x0(%rbp)，即输入1比较，不能相等，之后循环与输入1进行比较，比较完后令`%r13+=4`指向输入2，跳到+32进行输入范围验证，之后进行是否相等的验证，此处的代码在保证输入是1-6之间不重复的整数。

```asmatmel
=> 0x0000000000401153 <+95>:    lea    0x18(%rsp),%rsi
   0x0000000000401158 <+100>:   mov    %r14,%rax
   0x000000000040115b <+103>:   mov    $0x7,%ecx
   0x0000000000401160 <+108>:   mov    %ecx,%edx
   0x0000000000401162 <+110>:   sub    (%rax),%edx
   0x0000000000401164 <+112>:   mov    %edx,(%rax)
   0x0000000000401166 <+114>:   add    $0x4,%rax
   0x000000000040116a <+118>:   cmp    %rsi,%rax
   0x000000000040116d <+121>:   jne    0x401160 <phase_6+108>
   0x000000000040116f <+123>:   mov    $0x0,%esi
   0x0000000000401174 <+128>:   jmp    0x401197 <phase_6+163>
   0x0000000000401176 <+130>:   mov    0x8(%rdx),%rdx
   0x000000000040117a <+134>:   add    $0x1,%eax
   0x000000000040117d <+137>:   cmp    %ecx,%eax
   0x000000000040117f <+139>:   jne    0x401176 <phase_6+130>
   0x0000000000401181 <+141>:   jmp    0x401188 <phase_6+148>
   0x0000000000401183 <+143>:   mov    $0x6032d0,%edx
   0x0000000000401188 <+148>:   mov    %rdx,0x20(%rsp,%rsi,2)
   0x000000000040118d <+153>:   add    $0x4,%rsi
   0x0000000000401191 <+157>:   cmp    $0x18,%rsi
```

直到`%r12d = 6`。结束比较。到+95行。令`%rsi = 0x18(%rsp)`0x18 = 24,输入1储存在栈底，每个输入的大小为4字节，则此时%rsi指向位置为输入6的上面。此时

`%rax = %r14 = %rsp, %ecx = 7, %edx = %ecx = 7`接着%edx-%rax处的值(即栈底的输入1)储存在(%rax)处，就是原来输入1的位置。然后将%rax值+0x4，即指向输入2，进行循环，循环的结果是将输入值改为(7-x)。运行结束后`%esi = 0`，跳转到+163。

```asmatmel
   0x0000000000401195 <+161>:   je     0x4011ab <phase_6+183>
=> 0x0000000000401197 <+163>:   mov    (%rsp,%rsi,1),%ecx
   0x000000000040119a <+166>:   cmp    $0x1,%ecx
   0x000000000040119d <+169>:   jle    0x401183 <phase_6+143>
   0x000000000040119f <+171>:   mov    $0x1,%eax
   0x00000000004011a4 <+176>:   mov    $0x6032d0,%edx
   0x00000000004011a9 <+181>:   jmp    0x401176 <phase_6+130>
   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx
```

此时将运算后的输入1(简称为v1)相对偏移+%rsi的值给到`%ecx`。与0x1比较，先看<=1的情况，跳转到+143，将立即数`$0x6032d0`，给edx，并且储存到0x20(%rsp,%rsi,2)位置，可以看到此处与%rsp+0x18正好相差8个字节，之后`%rsi+0x4`，与0x18比较，判断进行操作的数据数量是否达到6个。不够继续从+163处运行，读取v2。现在看Vn>=1的情况(因为输入各不相同，所以<=1的判断只可能进行一次)。令`%eax = 1, %edx = 0x6032d0`跳转到+130，令%edx储存地址0x6032d0+0x8后储存的值存到%rdx中，通过打印地址0x6032d0处的值反馈名node1猜测此处储存的数据是一个链表。`%eax+=1`，比较其与%ecx的大小，不等于就跳转到+130。此处操作的用意在于得到相对于`0x6032d0`地址偏移vn*0x8后的值，存在%rdx中。通过gdb尝试`x/a 0x6032d0 + 0x8`结果为

`0x6032d8 <node1+8>:  0x6032e0 <node2>`，可以看出链表节点长度为16字节，从8字节开始存储下一个节点的地址。则节点的声明如下：

```c
struct _node{
    int val;
    struct _node* next;
}
```

从第8字节开始是因为对齐，所以int占4字节后空出4字节，地址从第8字节开始。

所以以上的操作是按照vn的大小作索引取得链表的节点。然后将`%rdx存到0x20(%rsp,%rsi,2)`，此时rdx里存放的是指向某个节点的指针。已知%rsi的更新长度是4字节，所以%rdx存放位置的更新长度的是8，所以此时栈上存放的是指向链表节点的指针，大小为8字节。整块的操作目的是将链表节点以某个顺序填在栈上。

```asmatmel
   0x00000000004011ab <+183>:   mov    0x20(%rsp),%rbx
   0x00000000004011b0 <+188>:   lea    0x28(%rsp),%rax
   0x00000000004011b5 <+193>:   lea    0x50(%rsp),%rsi
   0x00000000004011ba <+198>:   mov    %rbx,%rcx
   0x00000000004011bd <+201>:   mov    (%rax),%rdx
   0x00000000004011c0 <+204>:   mov    %rdx,0x8(%rcx)
   0x00000000004011c4 <+208>:   add    $0x8,%rax
   0x00000000004011c8 <+212>:   cmp    %rsi,%rax
   0x00000000004011cb <+215>:   je     0x4011d2 <phase_6+222>
   0x00000000004011cd <+217>:   mov    %rdx,%rcx
```

此时执行到+183行，令`%rbx = 0x20(%rsp)`，即储存的指向第一个节点的指针，`%rax = &0x28(%rsp)`，即下一个储存的节点指针的位置。lea 0x50(%rsp),%rsi将栈顶给到%rsi，最初一共给栈分派了0x50字节。`%rcx = %rbx, %rdx = (%rax), 0x8(%rcx) = %rdx`,这几个操作%rdx值为储存在栈上的下一个节点的地址，将它赋给储存的第一个节点中的next，即`node_1 -> next = node_2`（假设栈中储存的节点排列为1,2,3...向上索引增加）。之后将%rax，也就是指向栈上第二个结点的指针+0x8，指向第3个结点，循环这部分操作，相当于对排序后的链表重新连接。

```asmatmel
   0x00000000004011d0 <+220>:   jmp    0x4011bd <phase_6+201>
   0x00000000004011d2 <+222>:   movq   $0x0,0x8(%rdx)
   0x00000000004011da <+230>:   mov    $0x5,%ebp
   0x00000000004011df <+235>:   mov    0x8(%rbx),%rax
   0x00000000004011e3 <+239>:   mov    (%rax),%eax
   0x00000000004011e5 <+241>:   cmp    %eax,(%rbx)
   0x00000000004011e7 <+243>:   jge    0x4011ee <phase_6+250>
   0x00000000004011e9 <+245>:   call   0x40143a <explode_bomb>
   0x00000000004011ee <+250>:   mov    0x8(%rbx),%rbx
   0x00000000004011f2 <+254>:   sub    $0x1,%ebp
   0x00000000004011f5 <+257>:   jne    0x4011df <phase_6+235>
   0x00000000004011f7 <+259>:   add    $0x50,%rsp
```

+222行此时%rdx应该指向了最后一个节点，令节点的next项归零。即为空指针。

`%ebp = 0x5, %rax = 0x8(%rbx) = node1.next， %eax = (%rax) = *(node1.next) `，比较(%rbx)与%eax大小，分别为node1中的值和node1中next指向的下一节点的值，若小于则爆炸，此段代码保证此链表应该为降序排列。通过

`x/dw 0x6032d0`从原链表开始分别取出储存的值，为332 168 924 691 477 443，则索引应该为3 4 5 6 1 2 ，输入列应该为4 3 2 1 6 5

* gdb和x86-64对“字”的规定有区别，intel word 表示16位，双字为32位，四字为64位，所以后缀b w l q 分别为1 2 4 8 字节。gdb中x指令指定请求字节数的参数b h w g 分别表示1 2 4 8字节。

***

## secret_phase(未完成)

在对汇编文件查看过程中，可以发现在phase_6下面有func7和secret_phase，搜索下什么会call secret_phase，发现是<phase_defused>，具体是这样。

```asmatmel
  4015d1:	48 89 44 24 68       	mov    %rax,0x68(%rsp)
  4015d6:	31 c0                	xor    %eax,%eax
  4015d8:	83 3d 81 21 20 00 06 	cmpl   $0x6,0x202181(%rip)        # 603760 <num_input_strings>
  4015df:	75 5e                	jne    40163f <phase_defused+0x7b>
```

这段从名称可以看出是在比较输入的字符串数量和6的关系。只有前6关都通过才可能进入隐藏。同时可以看出如果每关的答案如果不用换行隔开就会提示因为字符串太长而爆炸。

```asmatmel

  4015f0:	be 19 26 40 00       	mov    $0x402619,%esi
  4015f5:	bf 70 38 60 00       	mov    $0x603870,%edi
  4015fa:	e8 f1 f5 ff ff       	call   400bf0 <__isoc99_sscanf@plt>
  4015ff:	83 f8 03             	cmp    $0x3,%eax
  401602:	75 31                	jne    401635 <phase_defused+0x71>
  401604:	be 22 26 40 00       	mov    $0x402622,%esi
  401609:	48 8d 7c 24 10       	lea    0x10(%rsp),%rdi
  40160e:	e8 25 fd ff ff       	call   401338 <strings_not_equal>
  401613:	85 c0                	test   %eax,%eax
  401615:	75 1e                	jne    401635 <phase_defused+0x71>
  401617:	bf f8 24 40 00       	mov    $0x4024f8,%edi
  40161c:	e8 ef f4 ff ff       	call   400b10 <puts@plt>
  401621:	bf 20 25 40 00       	mov    $0x402520,%edi
  401626:	e8 e5 f4 ff ff       	call   400b10 <puts@plt>
  40162b:	b8 00 00 00 00       	mov    $0x0,%eax
  401630:	e8 0d fc ff ff       	call   401242 <secret_phase>
```

通过x/s 0x402619 和x/s 0x603870，可以得到“%d %d %s” 和"7 0"，可以看到后一个地址是phase_4的答案的字符串版本，就然后比较scanf的返回值是否为3，不为3就正常打印出结束的字符串。所以进入隐藏关应该是在第四关的两个数字后面输入指定字符串。接着看下去，指定字符串应该储存在0x402622位置，此处为“DrEvil”。
